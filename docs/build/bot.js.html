<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bot.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Bot.html">Bot</a><ul class='methods'><li data-type='method'><a href="Bot.html#Connect">Connect</a></li><li data-type='method'><a href="Bot.html#GetChannel">GetChannel</a></li><li data-type='method'><a href="Bot.html#UpdateChannel">UpdateChannel</a></li><li data-type='method'><a href="Bot.html#DeleteChannel">DeleteChannel</a></li><li data-type='method'><a href="Bot.html#GetChannelMessages">GetChannelMessages</a></li></ul></li><li><a href="Disnode.html">Disnode</a><ul class='methods'><li data-type='method'><a href="Disnode.html#Start">Start</a></li><li data-type='method'><a href="Disnode.html#Stop">Stop</a></li><li data-type='method'><a href="Disnode.html#Restart">Restart</a></li><li data-type='method'><a href="Disnode.html#LoadBotConfig">LoadBotConfig</a></li><li data-type='method'><a href="Disnode.html#OnMessage">OnMessage</a></li></ul></li><li><a href="PluginManager.html">PluginManager</a><ul class='methods'><li data-type='method'><a href="PluginManager.html#LoadAllPlugins">LoadAllPlugins</a></li><li data-type='method'><a href="PluginManager.html#RunPluginMessage">RunPluginMessage</a></li><li data-type='method'><a href="PluginManager.html#LaunchPlugin">LaunchPlugin</a></li><li data-type='method'><a href="PluginManager.html#RunCommandBind">RunCommandBind</a></li><li data-type='method'><a href="PluginManager.html#AddServerPluginRemote">AddServerPluginRemote</a></li><li data-type='method'><a href="PluginManager.html#AddServerPluginLocal">AddServerPluginLocal</a></li><li data-type='method'><a href="PluginManager.html#RemoveServerPlugin">RemoveServerPlugin</a></li><li data-type='method'><a href="PluginManager.html#MakeServerFolder">MakeServerFolder</a></li><li data-type='method'><a href="PluginManager.html#GetPluginByID">GetPluginByID</a></li><li data-type='method'><a href="PluginManager.html#GetInstanceByID">GetInstanceByID</a></li><li data-type='method'><a href="PluginManager.html#GetPluginFiles">GetPluginFiles</a></li><li data-type='method'><a href="PluginManager.html#GetCommandPrefixes">GetCommandPrefixes</a></li><li data-type='method'><a href="PluginManager.html#GetCommandObject">GetCommandObject</a></li><li data-type='method'><a href="PluginManager.html#GetConfigFile">GetConfigFile</a></li><li data-type='method'><a href="PluginManager.html#GetCommandFile">GetCommandFile</a></li><li data-type='method'><a href="PluginManager.html#SetConfigFile">SetConfigFile</a></li><li data-type='method'><a href="PluginManager.html#SetCommandFile">SetCommandFile</a></li><li data-type='method'><a href="PluginManager.html#GetScriptRequire">GetScriptRequire</a></li></ul></li><li><a href="Util.html">Util</a><ul class='methods'><li data-type='method'><a href="Util.html#arrayToOject">arrayToOject</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="Bot.html#event:ready">ready</a></li><li><a href="Bot.html#event:channel_create">channel_create</a></li><li><a href="Bot.html#event:channel_delete">channel_delete</a></li><li><a href="Bot.html#event:channel_update">channel_update</a></li><li><a href="Bot.html#event:guild_ban_add">guild_ban_add</a></li><li><a href="Bot.html#event:guild_ban_remove">guild_ban_remove</a></li><li><a href="Bot.html#event:guild_create">guild_create</a></li><li><a href="Bot.html#event:guild_delete">guild_delete</a></li><li><a href="Bot.html#event:guild_intergrations">guild_intergrations</a></li><li><a href="Bot.html#event:guild_memeber_add">guild_memeber_add</a></li><li><a href="Bot.html#event:guild_memeber_removed">guild_memeber_removed</a></li><li><a href="Bot.html#event:guild_role_created">guild_role_created</a></li><li><a href="Bot.html#event:guild_role_delete">guild_role_delete</a></li><li><a href="Bot.html#event:guild_role_update">guild_role_update</a></li><li><a href="Bot.html#event:guild_update">guild_update</a></li><li><a href="Bot.html#event:message">message</a></li><li><a href="Bot.html#event:message_delete">message_delete</a></li><li><a href="Bot.html#event:message_update">message_update</a></li><li><a href="Bot.html#event:message_presence">message_presence</a></li><li><a href="Bot.html#event:typing">typing</a></li><li><a href="Bot.html#event:setting_update">setting_update</a></li><li><a href="Bot.html#event:voice_update">voice_update</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-NewDisnodePlugin.html">NewDisnodePlugin</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">bot.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const net = require('net');
const shortid = require('shortid');
const Discord = require('discord.io');
const Logger = require('disnode-logger');
const axios = require('axios');
const WebSocket = require('ws');
const codes = require("./api/codes");
const Logging = require('disnode-logger');
const requests = require('./api/request')
const APIUtil = require("./api/apiutils");
const async = require('async');
const EventEmitter = require('events').EventEmitter;


/**
 * Class to ineract with Discord
 * @constructor
 * @param {string} key - Discord Bot Key
 * @param {DisnodeObj} disnode - Refrence to Disnode Class (disnode.js)
 * @property {string} key - The Bot's Discord Key
 * @property {BotInfoObject} botInfo - Information about the bot
 * @property {Disnode} disnode - Disnode Refrence
 * @property {string} shardID - Bot's Shard ID
 * @property {string} lastS - Last 's' sent in a WS Packet (internal use mostly)
 * @property {Object&lt;GuildObject>} guilds - The Guilds the bot belonds to. Object so access via `this.disnode.bot.guilds[guildID]`
 * @property {Object&lt;ChannelObject>} channels - All the channels. Object so access via `this.disnode.bot.channels[channelID]`
 * @property {Object&lt;UserObject>} users - All the users. Object so access via `this.disnode.bot.users[userID]`
 */
class Bot extends EventEmitter {
  constructor(key, disnode) {
    super();
    this.key = key;
    this.botInfo = {};
    this.disnode = disnode;
    this.shardID = 0;
    this.lastS = null;
    this.guilds = {
      count: 0
    };
    this.channels = {
      count: 0
    };
    this.users = {
      count: 0
    };
  }

  /**
   * Connect bot to Discord
   */
  Connect() {
    var self = this;
    return new Promise(function(resolve, reject) {
      self.GetGatewayURL().then(function(url) {
        return self.ConnectToGateway(url)
      }).then(function() {
        self.on("ready", function() {
          self.GetCacheInfo();
          resolve();
        })
      }).catch(function(err) {
        Logger.Error("Bot", "Connect", "Connection Error: " + err);
      })
    });
  }

  ConnectToGateway(url) {
    var self = this;
    return new Promise(function(resolve, reject) {
      Logger.Info("Bot", "ConnectToGateway", "Connecting to gateway");
      self.ws = new WebSocket(url);

      self.BindSocketEvents();

      self.ws.on('open', function() {
        Logger.Success("Bot", "ConnectToGateway", "Connected to gateway!");
        resolve();
      });

    });
  }

  WSIdentify() {
    var self = this;
    Logger.Info("Bot", "wsIdentify", "Sending ID to Gateway");
    var packet = requests.identify(this.key);
    self.ws.send(JSON.stringify(packet));
  }

  StartHeartbeat(interval) {
    var self = this;
    Logger.Info("Bot", "StartHeartbeat", "Starting Heatbeat with Interval: " + interval);
    var packet = requests.heartbeat(self.lastS);
    self.ws.send(JSON.stringify(packet));

    setInterval(function() {
      var packet = requests.heartbeat(self.s);
      self.ws.send(JSON.stringify(packet));
    }, interval)
  }

  BindSocketEvents() {
    var self = this;
    self.ws.on("message", function(data, flags) {
      self.OnWSMessage(data, flags);

    });

    self.ws.on('error', function(error) {
      console.log(error);
      var ErrorObject = {
        message: error.message,
        status: "WS-000",
        display: "WebSocket Error [" + error.response.status + "] " + error.message,
        raw: error
      }
      Logger.Error("Bot", "WS-ERROR", ErrorObject.display);
      self.emit("error", ErrorObject);
    });
  }

  OnWSMessage(data, flags) {
    data = JSON.parse(data);
    var operation = data.op;
    var self = this;
    if (data.s) {
      self.s = data.s;
    }
    switch (operation) {
      case codes.OPCode.HELLO:

        self.wsIdentify();
        self.StartHeartbeat(data.d['heartbeat_interval'])
        break;

      case codes.OPCode.DISPATCH:
        self.handleDispatch(data);
        break;
      case codes.OPCode.HEARTBEAT_ACK:

        break;
    }
  }

  HandleDispatch(data) {
    var type = data.t;
    var self = this;
    //console.log(type);
    switch (type) {
      /**
       * Message Delete event.
       * @event Bot#ready
       * @type {object}
       * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
       */
      case codes.dispatch.READY:
        self.emit("ready");
        break;
        /**
         * Message Delete event.
         * @event Bot#channel_create
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.CHANNEL_CREATE:
        self.emit("channel_create", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#channel_delete
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.CHANNEL_DELETE:
        self.emit("channel_delete", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#channel_update
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.CHANNEL_UPDATE:
        self.emit("channel_update", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_ban_add
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_BAN_ADD:
        self.emit("guild_ban_add", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_ban_remove
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_BAN_REMOVE:
        self.emit("guild_ban_remove", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_create
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_CREATE:
        self.emit('guild_create', data.d);
        self.handleGuildCreate(data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_delete
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_DELETE:
        self.emit("guild_delete", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_intergrations
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_INTEGRATIONS_UPDATE:
        self.emit("guild_intergrations", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_memeber_add
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_MEMBER_ADD:
        self.emit("guild_memeber_add", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_memeber_removed
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_MEMBER_REMOVE:
        self.emit("guild_memeber_removed", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_role_created
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_ROLE_CREATE:
        self.emit("guild_role_created", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_role_delete
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_ROLE_DELETE:
        self.emit("guild_role_delete", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_role_update
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_ROLE_UPDATE:
        self.emit("guild_role_update", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#guild_update
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.GUILD_UPDATE:
        self.emit("guild_update", data.d);
        break;
        /**
         * Message Create event.
         * @event Bot#message
         * @type {object}
         * @property {MessageObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.MESSAGE_CREATE:
        var data = {
          id: data.d.id,
          user: data.d.author.username,
          userID: data.d.author.id,
          channel: data.d.channel_id,
          message: data.d.content,
          server: self.GetServerFromChanel(data.d.channel_id),
          raw: data.d
        };
        self.emit("message", data);
        break;

        /**
         * Message Delete event.
         * @event Bot#message_delete
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.MESSAGE_DELETE:
        var data = {
          id: data.d.id,
          channel: data.d.channel_id,
          server: self.GetServerFromChanel(data.d.channel_id),
          raw: data.d
        };
        self.emit("message_delete", data);
        break;
        /**
         * Message Update event.
         * @event Bot#message_update
         * @type {object}
         * @property {MessageObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.MESSAGE_UPDATE:
        var data = {
          id: data.d.id,
          channel: data.d.channel_id,
          message: data.d.content,
          server: self.GetServerFromChanel(data.d.channel_id),
          raw: data.d
        };
        self.emit("message_update", data);
        break;
        /**
         * Message Delete event.
         * @event Bot#message_presence
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.PRESENCE_UPDATE:
        self.emit("message_presence", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#typing
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.TYPING_START:
        self.emit("typing", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#setting_update
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.USER_SETTINGS_UPDATE:
        self.emit("setting_update", data.d);
        break;
        /**
         * Message Delete event.
         * @event Bot#voice_update
         * @type {object}
         * @property {MessageDeleteObject} Data - Indicates whether the snowball is tightly packed.
         */
      case codes.dispatch.VOICE_STATE_UPDATE:
        self.emit("voice_update", data.d);
        break;
    }
  }

  CacheGuild(data) {
    this.guilds[data.id] = data;
    for (var i = 0; i &lt; data.channels.length; i++) {
      data.channels[i].guild_id = data.id;

      this.channels[data.channels[i].id] = data.channels[i];
      this.channels.count += 1;
    }
    var mem = this.guilds[data.id].members

    var rawUsers = [];
    for (var i = 0; mem.length; i++) {
      if (mem[i] == null) {
        return;
      }
      this.users[mem[i].user.id] = mem[i].user;
    }
  }

  CacheBotUser() {
    var self = this;
    Logger.Info("Bot", "GetCacheInfo", "Caching Bot Info.");

    APIUtil.APIGet(self.key, "users/@me")
      .then(function(data) {
        Logger.Success("Bot", "GetCacheInfo", "Cached Bot Info!")
        self.botInfo = data;
      })
      .catch(function(err) {
        Logger.Error("Bot", "GetCacheInfo", "Error Caching Bot Info: " + err.display);
        reject(err);
      });
  }

  SetUpLocalBinds() {
    var self = this;
    self.on('message', function(data) {
      var firstLetter = data.message.substring(0, self.disnode.botConfig.prefix.length);
      if (self.disnode.ready &amp;&amp; firstLetter == self.disnode.botConfig.prefix) {
        this.disnode.server.GetCommandInstancePromise(data.server).then(function(inst) {
          if (inst) {
            inst.RunMessage(data);
          } else {
            Logging.Warning("Bot", "Message", "No Command Handler!");
          }
        });
      }
    });
  }

  GetGatewayURL() {
    var self = this;
    return new Promise(function(resolve, reject) {
      Logger.Info("Bot", "GetGatewayURL", "Aquiring Gatway URL...");

      APIUtil.APIGet(self.key, "gateway/bot")
        .then(function(data) {
          Logger.Success("Bot", "GetGatewayURL", "Aquired Gatway URL!");
          var url = data.url + "/?encoding=json&amp;v=5";
          resolve(url)
        })
        .catch(function(err) {
          Logger.Error("Bot", "GetGatewayURL", "Error Aquiring Gatway URL: " + err.display);
          reject(err);
        });
    });
  }

  /**
   * Get a channel by an ID
   * @param {string} channelID - ChannelID of where to send the message
   * @return {Promise&lt;ChannelObject|ErrorObject>} Return Channel Object
   */
  GetChannel(channelID) {
    var self = this;
    return new Promise(function(resolve, reject) {
      APIUtil.APIGet(self.key, "/channels/" + channelID)
        .then(function(data) {
          resolve(data);
        })
        .catch(function(err) {
          Logger.Error("Bot", "GetChannel", err.display);
          reject(err);
        });
    });
  }

  /**
   * Update a Channel
   * @param {string} channelID - ChannelID of where to send the message
   * @return {Promise&lt;ChannelObject|ErrorObject>} Return Promise
   */
  UpdateChannel(channelID, settings) {
    var self = this;
    return new Promise(function(resolve, reject) {
      APIUtil.APIPatch(self.key, "/channels/" + channelID, settings)
        .then(function(data) {
          resolve(data);
        })
        .catch(function(err) {
          Logger.Error("Bot", "UpdateChannel", err.display);
          reject(err);
        });
    });
  }

  /**
   * Delete a Channel
   * @param {string} channelID - ChannelID of where to send the message
   * @return {Promise&lt;ChannelObject|ErrorObject>} Return Promise
   */
  DeleteChannel(channelID) {
    var self = this;
    return new Promise(function(resolve, reject) {
      APIUtil.APIDelete(self.key, "/channels/" + channelID)
        .then(function(data) {
          resolve(data);
        })
        .catch(function(err) {
          Logger.Error("Bot", "DeleteChannel", err.display);
          reject(err);
        });
    });
  }

  /**
   * Returns the messages for a channel.
   * @param {string} channelID - ChannelID of where to send the message
   * @param {ChannelGetMessageSettings} settings - Settings for retriving messages (ALL OPTIONAL)
   * @return {Promise&lt;Array&lt;MessageObject>|ErrorObject>} Return Promise
   */
  GetChannelMessages(channelID, settings = {}) {
    var self = this;
    return new Promise(function(resolve, reject) {
      APIUtil.APIGet(self.key, "/channels/" + channelID + "/messages")
        .then(function(data) {
          resolve(data);
        })
        .catch(function(err) {
          Logger.Error("Bot", "GetChannelMessages", err.display);
          reject(err);
        });
    });
  }

}
module.exports = Bot;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Jun 14 2017 17:26:36 GMT-0700 (Pacific Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
